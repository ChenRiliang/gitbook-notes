# I/O模型 (unix 5种I/O模型)

#### 阻塞I/O模型

```
最常见的I/O模型，所有文件操作都是阻塞，套接字为例：在进程空间调用recvfrom,其系统调用知道数据包到达且被复制到应用程序的缓冲中或者发生错误才返回，在此期间一直会等待。
```

#### 非阻塞I/O模型

```
recvfrom从应用层到内核的时候，如果该缓冲区没有数据的话，就直接返回一个EWOULDBLOCK错误，一般对非阻塞I/O模型进行轮询检查这个状态，看内核是不是有数据到来。
```

#### I/O复用模型

```
linux提供select/poll，进程通过将一个或多个fd传递给select或者poll系统调用，阻塞在select操作上，这样select/poll可以帮我们侦测多个fd是否处于就绪状态。select/poll是顺序扫描fd是否就绪，而且支持的fd数量有限，因此它使用受到了一些限制，linux提供了一个epoll系统调用，epoll使用基于事件驱动方式代替顺序扫描，因此性能更高，当有fd就绪时，立即回调函数rollback
```

#### 信号驱动I/O模型

```
首先开启套接字接口驱动I/O功能，并通过系统调用sigaction执行一个信号处理函数（此系统调用立即返回，进程继续工作，它是非阻塞的）。当数据准备就绪时，就为该进程生成一个SIGIO信号，通过信号回调通知应用程序调用recvfrom来读取数据，并通知主循环函数处理数据
```

#### 异步I/O

```
告知内核启动某个操作，并让内核在整个操作完成后（包括将数据从内核复制到用户自己的缓冲区）通知我们。这种模型与信号驱动的主要区别是：信号驱动I/O由内核通知我们何时开始一个I/O操作；异步I/O模型由内核通知我们I/O操作何时完成
```



# I/O多路复用技术

```
1、在I/O编程过程中，当需要同时处理多个客户端接入请求，可以利用多线程或者I/O多路复用技术进行处理，I/O多路复用技术通过把多个I/O的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求，系统不需要创建新的进程或者线程，降低了维护工作。场景
   服务器需要同时处理多个处于监听状态或者多个连接状态的套接字
   服务器需要同时处理多种网络协议的套接字
2、目前支持I/O多路复用的系统调用有selct、pselect、poll、epoll,在linux编程中很长一段时select做轮询和网络事件通知，然而select的一些固有缺陷导致它的应用受到很大的限制，最终选择了epoll，现总结如下。

```



# 零拷贝

```
   零拷贝在 I/O 复用模型中，执行读写 I/O 操作依然是阻塞的，在执行读写 I/O 操作时，存在着多次内存拷贝和上下文切换，给系统增加了性能开销。
   
   零拷贝是一种避免多次内存复制的技术，用来优化读写 I/O 操作。
   
   在网络编程中，通常由 read、write 来完成一次 I/O 读写操作。每一次 I/O 读写操作都需要完成四次内存拷贝，路径是 I/O 设备 -> 内核空间 -> 用户空间 -> 内核空间 -> 其它 I/O 设备。
   
   Linux 内核中的 mmap 函数可以代替 read、write 的 I/O 读写操作，实现用户空间和内核空间共享一个缓存数据。mmap 将用户空间的一块地址和内核空间的一块地址同时映射到相同的一块物理内存地址，不管是用户空间还是内核空间都是虚拟地址，最终要通过地址映射映射到物理内存地址。这种方式避免了内核空间与用户空间的数据交换。I/O 复用中的 epoll 函数中就是使用了 mmap 减少了内存拷贝。
   
   在 Java 的 NIO 编程中，则是使用到了 Direct Buffer 来实现内存的零拷贝。Java 直接在 JVM 内存空间之外开辟了一个物理内存空间，这样内核和用户进程都能共享一份缓存数据。这是在 08 讲中已经详细讲解过的内容，你可以再去回顾下。
```





#### 参考资料

```
《netty权威指南》
https://time.geekbang.org/column/article/100861
```

