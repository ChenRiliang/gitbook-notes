# 类加载过程

```
java虚拟机中类加载的全过程，也就是加载、验证、准备、解析和初始化这5个阶段所执行的具体动作。
```



#### 加载

```
1、通过一个类的全限定名来获取定义此类的二进制字节流
2、讲这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3、在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据访问的入口

加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了，方法区中的数据存储格式完全由虚拟机实现自行定义，《Java虚拟机规范》 未规定此区域的具体数据结构。 类型数据妥善安置在方法区之后，会在Java堆内存中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区中的类型数据的外部接口。
```

#### 验证

```
一、文件格式验证
1、是否以0xCAFEBABE开头
2、主次版本号是否在Java虚拟机接受范围之内
3、指向常量中是否有不被支持的常量类型（检查常量tag标志）
4、Class文件中各个部分及文件本身是否有被删除的附加的其他信息
二、元数据验证
1、这个类是否有父类（除java.lang.Object之外，所有的类都应当有父类）
2、这个类的父类是否继承了不允许被继承的类（被final修饰的类）
3、如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法
4、类中的字段、方法是否与父类产生矛盾（例如覆盖父类final字段，或者出现不符合的方法重载，例如方法参数都一致，但返回值类型却不同等）。
三、字节码验证
1、保证任何跳转指令都不会跳转到方法体以外的字节码指令上
四、符号引用验证
  最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用[3]的时候， 这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。本阶段通常需要校验下列内容：
·符号引用中通过字符串描述的全限定名是否能找到对应的类。
·在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。
·符号引用中的类、 字段、 方法的可访问性（private、 protected、 public、 <package>） 是否可被当前类访问。
符号引用验证的主要目的是确保解析行为能正常执行， 如果无法通过符号引用验证，Java虚拟机
将会抛出一个java.lang.IncompatibleClassChangeError的子类异常，典型的如：
java.lang.IllegalAccessError、java.lang.NoSuchFieldError、 java.lang.NoSuchMethodError等。
验证阶段对于虚拟机的类加载机制来说，是一个非常重要的、但却不是必须要执行的阶段，因为验证阶段只有通过或者不通过的差别，只要通过了验证，其后就对程序运行期没有任何影响了。如果程序运行的全部代码（包括自己编写的、第三方包中的、从外部加载的、动态生成的等所有代码）都已经被反复使用和验证过，在生产环境的实施阶段就可以考虑使用-Xverify：none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。
```

#### 准备

```
  准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量的初始值阶段，从概念上讲，
  关于准备阶段，还有两个容易产生混淆的概念笔者需要进行强调，首先这时候进行分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在java堆中。其次是这里所说的初始值“通常情况”下是数据类型的零值，假设一个变量的定义为：public static int value = 123;
  那变量value在准备阶段过后的初始值为o儿不是123，因为这是尚未开始执行任何java方法，而把赋值为123的putstatic指令是程序被编译后，存放于类构造器<clinit>()方法之中，所以把value赋值123动作实在类的初始化阶段才被执行
  上面提到在“通常情况”下初始值是零值，那言外之意是相对的会有某些“特殊情况”：如果字段属性表中存在Constan Value属性，那在准备阶段变量值就会被初始化为Constant Value属性所指定的初始值，例：public static final int value =123;
```

#### 解析

```
解析阶段是java虚拟机将常量池的符号引用替换为直接引用的过程，
```

#### 初始化

```

```



参考资料

```
《深入理解java虚拟机》
```

